/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/


#include "VulnerabilityTests.h"
#include <pacman/model/GameState.h>
#include <pacman/test/model/PathTest.h>

#include <memory>

using std::cout;
using std::endl;
using std::vector;
using std::shared_ptr;

using namespace ::PACMAN::MODEL;
using namespace ::PACMAN::SPECIFICATION;

namespace PACMAN {
    namespace TEST {
        namespace MODEL {

/*
 * Test how long vulnerability lasts
 */
void VulnerabilityTests::test_energizer_time() {
    std::vector<Action> path = {0, 1, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1};
    PathTest test(path);

    // Note:
    // ct = distance from corner to tile edge
    // cc = distance from corner point to corner point
    // cw = distance from corner point to wall edge
    // ww = distance from wall entry to wall exit
    // s = 1 = distance of going straight for 1 tile 
    // ns = normal speed
    // es = energetic speed
    //
    // Exceptional cornering:
    // encw = normal corner point to wall
    // eww = wall to wall
    // eecw = exceptional corner point to wall
    //
    // distance is expressed in tiles (not pixels)

    auto state = test.run(142 +1);  // ct+cc+ct+ct+cc+ct+8s+ct+cc+ct+ct+encw + 17 dots
    ASSERT(state.get_vulnerable_ghost_count() == 0); // energizer takes effect in next tick, not this one

    state = test.run(143 +1);
    ASSERT(state.get_vulnerable_ghost_count() == 2);

    state = test.run(142 + VULNERABLE_TICKS +1);
    ASSERT(state.get_vulnerable_ghost_count() == 2); // energizer still active

    state = test.run(143 + VULNERABLE_TICKS +1);
    ASSERT(state.get_vulnerable_ghost_count() == 0); // and now it stops
}

/*
 * Test timing of vulnerability of 2 consecutive energizers before the first times out
 *
 * Note: also tests how long to idle at an energizer
 */
void VulnerabilityTests::test_2_energizers_time() {
    std::vector<Action> path = {0, 1, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1};
    PathTest test(path);

    // eat energizer
    auto state = test.run(142 +1);  // (ct+cc+ct+ct+cc+ct+8s+ct+cc+ct+ct+encw)/ns + 17 dots
    ASSERT(state.get_vulnerable_ghost_count() == 0);

    // eat another energizer before timeout
    state = test.run(392 +1);  // 142 + (eww+eecw+eecw+eww+encw+ct+cc+ct+cc+ct+cc+ct+12+ct+cc+ct+cc+ct+cc+ct+encw+eww+eecw+eecw)/es + 1 energizer + 33 dots
    ASSERT(state.get_vulnerable_ghost_count() == 2);

    // second energizer actives
    state = test.run(393 +1);
    ASSERT(state.get_vulnerable_ghost_count() == 3); 

    // energizer still active
    state = test.run(392 + VULNERABLE_TICKS +1);
    ASSERT(state.get_vulnerable_ghost_count() == 3); 

    // energizer stops
    state = test.run(393 + VULNERABLE_TICKS +1);
    ASSERT(state.get_vulnerable_ghost_count() == 0);
}

}}}
