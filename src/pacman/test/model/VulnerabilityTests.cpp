/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/


#include "VulnerabilityTests.h"
#include <pacman/model/GameState.h>
#include <pacman/run/PlaybackInput.h>

#include <memory>

using std::cout;
using std::endl;
using std::vector;
using std::shared_ptr;

using namespace ::PACMAN::MODEL;
using namespace ::PACMAN::RUN;
using namespace ::PACMAN::SPECIFICATION;

namespace PACMAN {
    namespace TEST {
        namespace MODEL {

VulnerabilityTests::VulnerabilityTests(std::vector<Action>& path)
:   DefaultGameObserver(PLAYER_PACMAN, shared_ptr<Input>(new PlaybackInput(path)))
{
}

//void VulnerabilityTests::run(int quit_at_step) {
 //   game.run(*this, false, quit_at_step);
//}

/*
 * Test how long vulnerability lasts
 */
void VulnerabilityTests::test_energizer_time() {
    std::vector<Action> path = {0, 1, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1};
    VulnerabilityTests test(path);

    // Note:
    // ct = distance from corner to tile edge
    // cc = distance from corner point to corner point
    // cw = distance from corner point to wall edge
    // ww = distance from wall entry to wall exit
    // s = 1 = distance of going straight for 1 tile 
    // ns = normal speed
    // es = energetic speed
    //
    // Exceptional cornering:
    // encw = normal corner point to wall
    // eww = wall to wall
    // eecw = exceptional corner point to wall
    //
    // distance is expressed in tiles (not pixels)

    test.game.run(test, false, 142 +1);  // ct+cc+ct+ct+cc+ct+8s+ct+cc+ct+ct+encw + 17 dots
    auto state = test.game.get_state();
    ASSERT(state.get_vulnerable_ghost_count() == 0); // energizer takes effect in next tick, not this one

    test.game.run(test, false, 143 +1);
    state = test.game.get_state();
    ASSERT(state.get_vulnerable_ghost_count() == 2);

    test.game.run(test, false, 142 + VULNERABLE_TICKS +1);
    state = test.game.get_state();
    ASSERT(state.get_vulnerable_ghost_count() == 2); // energizer still active

    test.game.run(test, false, 143 + VULNERABLE_TICKS +1);
    state = test.game.get_state();
    ASSERT(state.get_vulnerable_ghost_count() == 0); // and now it stops
}

/*
 * Test timing of vulnerability of 2 consecutive energizers before the first times out
 *
 * Note: also tests how long to idle at an energizer
 */
void VulnerabilityTests::test_2_energizers_time() {
    std::vector<Action> path = {0, 1, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1};
    VulnerabilityTests test(path);

    // eat energizer
    test.game.run(test, false, 142 +1);  // (ct+cc+ct+ct+cc+ct+8s+ct+cc+ct+ct+encw)/ns + 17 dots
    auto state = test.game.get_state();
    ASSERT(state.get_vulnerable_ghost_count() == 0);

    // eat another energizer before timeout
    test.game.run(test, false, 392 +1);  // 142 + (eww+eecw+eecw+eww+encw+ct+cc+ct+cc+ct+cc+ct+12+ct+cc+ct+cc+ct+cc+ct+encw+eww+eecw+eecw)/es + 1 energizer + 33 dots
    state = test.game.get_state();
    ASSERT(state.get_vulnerable_ghost_count() == 2);

    // second energizer actives
    test.game.run(test, false, 393 +1);
    state = test.game.get_state();
    ASSERT(state.get_vulnerable_ghost_count() == 3); 

    // energizer still active
    test.game.run(test, false, 392 + VULNERABLE_TICKS +1);
    state = test.game.get_state();
    ASSERT(state.get_vulnerable_ghost_count() == 3); 

    // energizer stops
    test.game.run(test, false, 393 + VULNERABLE_TICKS +1);
    state = test.game.get_state();
    ASSERT(state.get_vulnerable_ghost_count() == 0);
}

}}}
